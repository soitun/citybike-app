<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Swifternalization  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
  </head>
  <body>
    <a title="Swifternalization  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Swifternalization Docs</a> (100% documented)</p>
        <p class="header-right"><a href=""><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Swifternalization Reference</a>
        <img id="carat" src="img/carat.png" />
        Swifternalization  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
          <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/InequalityExpressionParser.html">InequalityExpressionParser</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/InequalityExtendedExpressionParser.html">InequalityExtendedExpressionParser</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/JSONFileLoader.html">JSONFileLoader</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/LoadedTranslationsProcessor.html">LoadedTranslationsProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Regex.html">Regex</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/RegexExpressionParser.html">RegexExpressionParser</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/SharedBaseExpression.html">SharedBaseExpression</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/SharedExpressionsLoader.html">SharedExpressionsLoader</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/SharedExpressionsProcessor.html">SharedExpressionsProcessor</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/SharedPolishExpression.html">SharedPolishExpression</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Swifternalization.html">Swifternalization</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/TranslationsLoader.html">TranslationsLoader</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Enums.html">Enums</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/ExpressionPatternType.html">ExpressionPatternType</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/InequalitySign.html">InequalitySign</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/InternalPattern.html">InternalPattern</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/LoadedTranslationType.html">LoadedTranslationType</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/s:ZF17Swifternalizationoi2lnFTGSaVS_16SharedExpression_GSaS0___GSaS0__">&lt;!(_:_:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/ExpressionMatcher.html">ExpressionMatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ExpressionParser.html">ExpressionParser</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/SharedExpressionProtocol.html">SharedExpressionProtocol</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Structs.html">Structs</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/Expression.html">Expression</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/InequalityExpressionMatcher.html">InequalityExpressionMatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/InequalityExtendedExpressionMatcher.html">InequalityExtendedExpressionMatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/LengthVariation.html">LengthVariation</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/LoadedTranslation.html">LoadedTranslation</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/RegexExpressionMatcher.html">RegexExpressionMatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/SharedExpression.html">SharedExpression</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Translation.html">Translation</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Typealiases.html">Typealiases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization11CountryCode">CountryCode</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization17ExpressionPattern">ExpressionPattern</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization4I18n">I18n</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization14JSONDictionary">JSONDictionary</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization12RegexPattern">RegexPattern</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p><img src="https://raw.githubusercontent.com/tomkowz/Swifternalization/master/page-assets/swifternalization-header.png" alt="Swifternalization: localize apps smarter"></p>

<p><img src="https://img.shields.io/cocoapods/v/Swifternalization.svg" alt="CocoaPods Status"></p>
<a href='#swifternalization' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='swifternalization'>Swifternalization</h1>

<p>Swift library that helps in localizing apps in a different, better, simpler, more powerful way than system localization does. It uses json files instead of strings files.</p>
<a href='#features' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='features'>Features</h1>

<ul>
<li>[x] Pluralization support - Without using <em>stringdict</em> files</li>
<li>[x] Length variations support - Supported since iOS 8.0 (instead of iOS 9.0 like system does) and avoids using <em>stringsdict</em> files</li>
<li>[x] Expressions - inequality and regular expressions</li>
<li>[x] Shared Expressions</li>
<li>[x] Built-in Expressions</li>
<li>[x] Works similarly to NSLocalizedString()</li>
<li>[x] Uses JSON files to minimize boilerplate code</li>
<li>[x] Comprehensive Unit Test Coverage</li>
<li>[x] Full documentation</li>
</ul>
<a href='#table_of_contents' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='table_of_contents'>Table of Contents</h1>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#practical-usage-example">Practical Usage Example</a></li>
<li><a href="#features-1">Features</a>

<ul>
<li><a href="#pluralization">Pluralization</a></li>
<li><a href="#length-variations">Length variations</a></li>
</ul></li>
<li><a href="#expressions">Expressions</a>

<ul>
<li><a href="#inequality-expressions">Inequality Expressions</a></li>
<li><a href="#inequality-extended-expressions">Inequality Extended Expressions</a></li>
<li><a href="#regex-expressions">Regex Expressions</a></li>
<li><a href="#shared-expressions">Shared Expressions</a></li>
<li><a href="#built-in-expressions">Built-in Expressions</a></li>
</ul></li>
<li><a href="#getting-started">Getting Started</a>

<ul>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#creating-file-with-shared-expressions">Creating file with shared expressions</a></li>
<li><a href="#creating-file-with-localization-per-country">Creating file with localization per country</a></li>
<li><a href="#getting-localized-string">Getting localized string</a></li>
</ul></li>
<li><a href="#contribution">Contribution</a></li>
<li><a href="#swift-2">Swift 2</a></li>
<li><a href="#things-to-do-in-future-releases">Things To Do</a></li>
<li><a href="#license">License</a></li>
</ul>
<a href='#introduction' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='introduction'>Introduction</h2>

<p>Swifternalization helps in localizing apps in a smarter way. It has been created because of necessity to solve Polish language internalization problems but it is universal and works with every language very well.</p>

<p>It uses JSON files and expressions that avoid writing code to handle some cases that you have to write when not using this framework. It makes localizing process simpler.</p>
<a href='#practical_usage_example' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='practical_usage_example'>Practical Usage Example</h2>

<p>Description of practical usage example will use things that are covered later in the document so keep reading it to the end and then read about details/features presented here.</p>
<a href='#problem' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='problem'>Problem</h3>

<p>Let&rsquo;s assume the app supports English and Polish languages. Naturally app contains two <em>Localizable.strings</em> files. One is for <em>Base</em> localization which contains <em>English</em> translation and one is <em>Polish</em> language. </p>

<p>App displays label with information which says when object from the backend has been updated for the last time, e.g. <q>2 minutes ago</q>, <q>3 hours ago</q>, <q>1 minute ago</q>, etc.</p>
<a href='#analysis' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='analysis'>Analysis</h3>

<p>The label displays number and a hour/minute/second word in singular or plural forms with <q>ago</q> suffix. Different languages handles pluralization/cardinal numbering in slight different ways. Here we need to support English and Polish languages.</p>

<p>In English there are just two cases to cover per hour/minute/second word:</p>

<ul>
<li>1 - <q>one second ago</q></li>
<li>0, 2, 3&hellip; <q>%d seconds ago</q></li>
<li>Same with minutes and hours. </li>
</ul>

<p>In Polish it is more tricky because the cardinal numbers are more complicated:</p>

<ul>
<li>1 - <q>jedną sekundę temu</q></li>
<li>0, (5 - 21) - <q>%d sekund temu</q></li>
<li>(2 - 4), (22-24), (32-34), (42, 44), &hellip;, (162-164), &hellip; - <q>%d sekundy temu</q></li>
<li>Same logic for minutes and hours. </li>
</ul>

<p>Following chapters will present solution without and with Swifternalization framework. Each solution describes Base (English) and Polish localizations.</p>

<p>Here is a table with <a href="http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html">Language Plural Rules</a> which covers cardinal forms of numbers in many languages - Many language handle plurality in their own way.</p>
<a href='#solution_without_swifternalization' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='solution_without_swifternalization'>Solution without Swifternalization</h3>
<pre class="highlight plaintext"><code>Localizable.strings (Base)
--------------------------
"one-second" = "1 second ago";
"many-seconds" = "%d seconds ago";

"one-minute" = "1 minute ago";    
"many-minutes" = "%d minutes ago";

"one-hour" = "1 hour ago";
"many-hours" = "%d hours ago";

Localizable.strings (Polish)
-------------------------               
"one-second" = "1 sekundę temu"
"few-seconds" = "%d sekundy temu"
"many-seconds" = "%d sekund temu""              

"one-minute" = "1 minutę temu"
"few-minutes" = "%d minuty temu "
"many-minutes" = "%d minut temu"            

"one-hours" = "1 godzinę temu"
"few-hours" = "%d godziny temu"
"many-hours" = "%d godzin temu";
</code></pre>

<p>There are 6 cases in English and 9 cases in Polish. Notice that without additional logic we&rsquo;re not able to detect which version of a string for hour/minute/second the app should display. The logic differs among different languages. We would have to add some lines of code that handle the logic for all the languages we&rsquo;re using in the app. What if there are more than 2 languages? Don&rsquo;t even think about it - this might be not so easy.</p>

<p><em>The logic is already implemented in Swifternalization framework and it fits to every language.</em></p>
<a href='#solution_with_swifternalization' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='solution_with_swifternalization'>Solution with Swifternalization</h3>

<p>This is how localizable files will look:</p>
<pre class="highlight plaintext"><code>base.json
---------
"time-seconds": {
    "one": "%d second ago"
    "other": "%d seconds ago"
},

"time-minutes": {
    "one": "%d minute ago"
    "other": "%d minutes ago"
},

"time-hours": {
    "one": "%d hours ago"
    "other": "%d hours ago"
}

pl.json
-------
"time-seconds": {
    "one": "1 sekundę temu",
    "few": "%d sekundy temu",
    "many": "%d sekund temu"
},

"time-minutes": {
    "one": "1 minutę temu",
    "few": "%d minuty temu",
    "many": "%d minut temu"
},

"time-hours": {
    "one": "1 godzinę temu",
    "few": "%d godziny temu",
    "many": "%d godzin temu"
}
</code></pre>

<ul>
<li><q>one</q>, <q>few</q>, <q>many</q>, <q>other</q> - those are shared expressions already built into Swifternalization - covered below.</li>
<li>You can add own expressions to handle specific cases - covered below.</li>
</ul>

<p>As mentioned the logic is implemented into framework so if you want to get one of a localized string you have to make a simple call.</p>
<pre class="highlight plaintext"><code>Swifternalization.localizedString("time-seconds", intValue: 10)
</code></pre>

<p>or with <code>I18n</code> <em>typealias</em> (<em>I-18-letters-n, Internalization</em>):</p>
<pre class="highlight plaintext"><code>I18n.localizedString("time-seconds", intValue: 10)
</code></pre>

<p>The <em>key</em> and <em>intValue</em> parameters are validated by loaded expressions and proper version of a string is returned - covered below.</p>
<a href='#features' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='features'>Features</h2>
<a href='#pluralization' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='pluralization'>Pluralization</h3>

<p>Swifternalization drops necessity of using <em>stringdicts</em> files like following one to support pluralization in localized strings. Instead of that you can simply define expressions that cover such cases.</p>
<pre class="highlight plaintext"><code>&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;%d file(s) remaining&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;NSStringLocalizedFormatKey&lt;/key&gt;
            &lt;string&gt;%#@files@&lt;/string&gt;
            &lt;key&gt;files&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;NSStringFormatSpecTypeKey&lt;/key&gt;
                &lt;string&gt;NSStringPluralRuleType&lt;/string&gt;
                &lt;key&gt;NSStringFormatValueTypeKey&lt;/key&gt;
                &lt;string&gt;d&lt;/string&gt;
                &lt;key&gt;one&lt;/key&gt;
                &lt;string&gt;%d file remaining&lt;/string&gt;
                &lt;key&gt;other&lt;/key&gt;
                &lt;string&gt;%d files remaining&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>No more <em>stringsdict</em> files!</p>
<a href='#length_variations' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='length_variations'>Length Variations</h3>

<p>iOS 9 provides new way to select proper localized string variation depending on a screen width. It uses <em>stringsdict</em> file with <em>NSStringVariableWidthRuleType</em> key. </p>

<p>Swifternalization drops necessity of using such file and it is not necessary to use this new key to use the feature. </p>

<p><strong>With Swifternalization this length variations feature is available since iOS 8.0 because the framework has its own implementation of length variations.</strong></p>

<p>To use length variations feature your translation file should has entries like this:</p>
<pre class="highlight plaintext"><code>base.json
---------
"forgot-password": {
    "@200": "Forgot Password? Help.",
    "@300": "Forgot Your Password? Use Help.",
    "@400": "Do not remember Your Password?" Use Help.""
}
</code></pre>

<p>The number after <code>@</code> sign is max width of a screen or bounds that a string fits to. E.g. the second string will be returned if passed fitting width as a paramter is be greater than 200 and less or equal 300.</p>

<p>To get the second localized string the call looks like below:</p>
<pre class="highlight plaintext"><code>I18n.localizedString("forgot-password", fittingWidth: 300) // 201 - 300
</code></pre>

<p>You can mix expressions with length variations. Following example shows it:</p>
<pre class="highlight plaintext"><code>base.json
---------
"car": {
    "ie:x=1": {
        @100: "One car",
        @200: "You've got one car"
    },

    "more": "You've got few cars"
}
</code></pre>
<a href='#expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='expressions'>Expressions</h2>

<p>There are few <em>expression types</em>. Every expression type has their own <em>parser</em> and <em>matcher</em> but they work internally so you don&rsquo;t need to worry about them.</p>

<p>There are 3 types of expressions:</p>

<ul>
<li><em>inequality</em> - handles simple inequalities like: <em>x&lt;3</em>, <em>x&gt;10</em>, <em>x=5</em>, <em>x&lt;=3</em>, and so on. Work with integer and float numbers.</li>
<li><em>inequality extended</em> - extended version of <em>inequality</em> with syntax like this: <em>2&lt;x&lt;10</em>, <em>4&lt;=x&lt;6</em>. Work with integer and float numbers.</li>
<li><em>regex</em> - uses regular expression. This is the most powerful ;)</li>
</ul>
<a href='#inequality_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='inequality_expressions'>Inequality Expressions</h3>

<p>It is composed of several elements:</p>

<ul>
<li><em>ie:</em> - prefix of <em>inequality</em> expression</li>
<li><em>x</em> - you have to always pass it, this means here is the place for a number that will be matched. Works with Ints and floating point numbers.</li>
<li><em>&lt;, &lt;=, =, &gt;=, &gt;</em> - use one of inequality signs</li>
<li><em>1, 3, 5, 6, &hellip;</em> - value to match is the last one in this expression</li>
</ul>

<p>Example:</p>
<pre class="highlight plaintext"><code>"cars": {
    "ie:x=1": "1 car",
    "ie:x=0": "no cars",
    "ie:x&gt;1": "%d cars"
}
</code></pre>
<a href='#inequality_extended_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='inequality_extended_expressions'>Inequality Extended Expressions</h3>

<p>This is extended version of <em>inequality</em> expression. It is composed of 2 values, one value <q>marker</q> and two inequality signs.</p>

<ul>
<li><em>iex:</em> - prefix of <em>inequality extended</em> expression</li>
<li><em>x</em> - place for number that will be matched. Works with Ints and floating point numbers.</li>
<li>Only <em>&lt;</em> and <em>&lt;=</em> are accepted.</li>
</ul>

<p>Expample:</p>
<pre class="highlight plaintext"><code>"tomatos": {
    "iex:2&lt;x&lt;10": "%d tomatos is between 2 and 10"
}
</code></pre>
<a href='#regex_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='regex_expressions'>Regex Expressions</h3>

<p>This is the most powerful type of expression. It takes regular expression ;)</p>

<ul>
<li><em>exp:</em> - prefix of <em>regex</em> expression</li>
<li><em>string</em> - it takes string with regular expression</li>
</ul>

<p>Example: (police cars in Polish language)</p>
<pre class="highlight plaintext"><code>"police-cars": {
    "exp:^1$": "1 samochód policyjny",
    "exp:(((?!1).[2-4]{1})$)|(^[2-4]$)": "%d samochody policyjne",
    "exp:(.*(?=1).[0-9]$)|(^[05-9]$)|(.*(?!1).[0156789])": "%d samochodów policyjnych"
}
</code></pre>

<p>Powerful stuff, isn&rsquo;t it? :&gt;</p>

<p>PS. There is built-in solution for Polish language so you can use it with doing just this:</p>
<pre class="highlight plaintext"><code>"police-cars": {
    "one": "1 samochód policyjny",
    "few": "%d samochody policyjne",
    "many": "%d samochodów policyjnych"
}   
</code></pre>

<p>This is called <em><q>Shared Built-In Expression</q></em> and is covered below.</p>
<a href='#shared_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='shared_expressions'>Shared Expressions</h3>

<p>Shared expressions are expressions available among all the localization files. They are declared in <em>expressions.json</em> file divided by language and you can use them in localization files.</p>

<p>The functionality allows developer to observance of DRY principle and to avoid mistakes that exist because of reapeating the code in many places.</p>

<p>Normally you declare expression like this:</p>
<pre class="highlight plaintext"><code>...
"ie:x&gt;1": "Localized String"
...
</code></pre>

<p>If you want to use the same expression in multiple files there is no necessity to repeat the expression elsewhere. This is even problematic when you decide to improve/change expression to handle another cases you forget about - you would have to change expression in multiple places. Because of that there are Shared Expression. These feature allows you to create expression just in one place and use identifier of it in multiple places where you normally should put this expression.</p>

<p>What you need to do is to create <em>expressions.json</em> file with following structure:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"base"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"one"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ie:x&gt;1"</span><span class="w">
    </span><span class="p">},</span><span class="w">

    </span><span class="nt">"pl"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="err">other</span><span class="w"> </span><span class="err">than</span><span class="w"> </span><span class="nt">"one"</span><span class="w"> </span><span class="err">because</span><span class="w"> </span><span class="nt">"one"</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">available</span><span class="w"> </span><span class="err">here</span><span class="w"> </span><span class="err">too.</span><span class="w">
    </span><span class="err">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Now in <em>pl.json</em>, <em>en.json</em> and so on you have to use it as below:</p>
<pre class="highlight plaintext"><code>...
"one": "Localized String"
...
</code></pre>

<p>Before you decide to create your own expression take a look if there is no built-in one with the same name or whether there is such expression but named differently. Maybe you don&rsquo;t need to do this at all and just use it.</p>
<a href='#built_in_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='built_in_expressions'>Built-in expressions</h3>

<p>Built-in expressions as name suggest are shared expressions built into framework and available to use with zero configuration. They are separated by country and not all country have its own built-in expressions. For now there are e.g. Base built-in expressions and Polish built-in expressions. Base expressions are available in every country and there are very generic to match all countries pluralization/cardinal numbering logic. </p>

<p>List of supported built-in shared expressions:</p>
<pre class="highlight plaintext"><code>Base (English fits to this completely)
- one - detects if number is equal 1
- &gt;one - detects if number is greater than 1
- two - detects if number is equal 2
- other - detects if number is not 1, so 0, 2, 3 and so on.

Polish
- few - matches (2-4), (22-24), (32-4), ..., (..&gt;22, ..&gt;23, ..&gt;24)
- many - matches 0, (5-9), (10-21), (25-31), ..., (..0, ..1, ..5-9)
</code></pre>

<p>As you can see polish has no <q>one</q>, <q>>one</q>, etc. because it inherits from Base by default.</p>
<a href='#getting_started' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='getting_started'>Getting Started</h2>

<p>This chapter shows you how to start using Swifternalization and how to intergrate it with your code.</p>
<a href='#documentation' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='documentation'>Documentation</h3>

<p>Documentation covers 100% of the code, Yay! There are two types of documentation. First covers only public API which is for those who only want to use the framework without looking inside. The second one covers all the API - public, internal and private. </p>

<p>You can find Public API and Full documentation with docset here in <a href="https://github.com/tomkowz/Swifternalization/tree/master/docs">docs</a> directory. </p>

<p>It is also hosted on <a href="http://szulctomasz.com">my blog</a>:
- <a href="http://szulctomasz.com/docs/swifternalization/public/">Public API documentation</a>
- <a href="http://szulctomasz.com/docs/swifternalization/framework/">Full API documentation</a></p>

<p>Docsets:
- <a href="http://szulctomasz.com/docs/swifternalization/public/docsets/Swifternalization%20Public%20API.docset.zip">Public API docset</a>
- <a href="http://szulctomasz.com/docs/swifternalization/framework/docsets/Swifternalization.docset.zip">Full API docset</a></p>
<a href='#installation' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='installation'>Installation</h3>

<p>It works with iOS 8.0 and newer.</p>

<p>With CocoaPods:</p>
<pre class="highlight plaintext"><code>pod 'Swifternalization', '~&gt; 1.2'
</code></pre>

<p>If you are not using CocoaPods just import files from <em>Swifternalization/Swifternalization</em> directory to your project.</p>

<p>Swifternalization also supports Carthage.</p>
<a href='#configuration' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='configuration'>Configuration</h3>

<p>Before you get a first localized string you have to configure Swifternalization by passing to it the bundle where localized json files are placed.</p>
<pre class="highlight plaintext"><code>I18n.configure() // for NSBundle.mainBundle() - Mostly you want to call it this way
I18n.configure(bundle) // if files are in another bundle
</code></pre>
<a href='#creating_file_with_shared_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='creating_file_with_shared_expressions'>Creating file with Shared Expressions</h3>

<p>Shared Expressions must be placed in <em>expressions.json</em>. Syntax of a file looks like below:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"base"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"ten"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ie:x=10"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"&gt;20"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ie:x&gt;20"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"custom-pl-few"</span><span class="p">:</span><span class="w"> </span><span class="s2">"exp:(.*(?=1).[0-9]$)|(^[05-9]$)|(.*(?!1).[0156789])"</span><span class="w">
    </span><span class="p">},</span><span class="w">

    </span><span class="nt">"pl"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"few"</span><span class="p">:</span><span class="w"> </span><span class="s2">"exp:(((?!1).[2-4]{1})$)|(^[2-4]$)"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"two"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ie:x=2"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"three"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ie:x=3"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>In pseudo-language:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"language-1"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"shared-expression-key-1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"expression-1"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"shared-expression-key-2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"expression-2"</span><span class="w">
    </span><span class="p">},</span><span class="w">

    </span><span class="nt">"language-2"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"shared-expression-key-1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"expression-1"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Expressions from the files may be used inside localizable files. All the shared expressions for different languages are placed in the same file because there will be just few expressions for every language. Mostly the expression will be defined in <em>base</em> variant because if expression is in <em>base</em> it is also available in every other language too. So, <q>ten</q> is available in <q>pl</q>, but <q>three</q> is not available in <q>base</q>.</p>
<a href='#creating_file_with_localization_per_country' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='creating_file_with_localization_per_country'>Creating file with localization per country</h3>

<p>Localizable file contains translations for specific language. The files might look like below:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"welcome-key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"welcome"</span><span class="p">,</span><span class="w">

    </span><span class="nt">"cars"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"one"</span><span class="p">:</span><span class="w"> </span><span class="s2">"one car"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"ie:x&gt;=2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"%d cars"</span><span class="p">,</span><span class="w">
        </span><span class="nt">"ie:x&lt;=-2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"minus %d cars"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>Name of a file should be the same like country code. e.g. for English it is <em>en.json</em>, for Polish it is <em>pl.json</em>, for base localization it is <em>base.json</em>, etc.</p>

<p>There are few things that you can place in such files. More complex file will look like below:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"welcome"</span><span class="p">:</span><span class="w"> </span><span class="s2">"welcome"</span><span class="p">,</span><span class="w">

    </span><span class="nt">"cars"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"one"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"@100"</span><span class="p">:</span><span class="w"> </span><span class="s2">"one car"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"@200"</span><span class="p">:</span><span class="w"> </span><span class="s2">"You have one car"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"@400"</span><span class="p">:</span><span class="w"> </span><span class="s2">"You have got one car"</span><span class="w">
        </span><span class="p">},</span><span class="w">

        </span><span class="nt">"other"</span><span class="p">:</span><span class="w"> </span><span class="s2">"%d cars"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>

<p>In pseudo-language:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value"</span><span class="p">,</span><span class="w">

    </span><span class="nt">"key"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"expression-1"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nt">"length-variation-1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value-1"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"length-variation-2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value-2"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"length-variation-3"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value-3"</span><span class="w">
        </span><span class="p">},</span><span class="w">

        </span><span class="nt">"expression-2"</span><span class="p">:</span><span class="w"> </span><span class="s2">"value"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
<a href='#getting_localized_string' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='getting_localized_string'>Getting localized string</h3>

<p>Swifternalization allows you to work with its one class method which exposes all the methods you need to localize an app.</p>

<p>These methods have many optional paramters and you can omit them if you want. There are few common parameters:</p>

<ul>
<li><code>key</code> - A key of localized string.</li>
<li><code>fittingWidth</code> - A width of a screen or place where you want to put a localized string. It is integer.</li>
<li><code>defaultValue</code> - A value that will be returned if there is no localized string for a key passed to the method. If this is not specified then <code>key</code> is returned.</li>
<li><code>comment</code> - A comment used just by developer to know a context of translation.</li>
</ul>

<p>First method called <code>localizedString(_:fittingWidth:defaultValue:comment:)</code> allows you to get value for simple key without expression.</p>

<p>Examples:</p>
<pre class="highlight plaintext"><code>I18n.localizedString("welcome")
I18n.localizedString("welcome", fittingWidth: 200)
I18n.localizedString("welcome", defaultValue: "Welcome", comment: "Displayed on app start")
</code></pre>

<p>Next method <code>localizedString(_:stringValue:fittingWidth:defaultValue:comment:)</code> allows you to get a localized string for string value that match an expression. Actually the string value will contain number inside in most cases or some other string that you would like to match.</p>
<pre class="highlight plaintext"><code>I18n.localizedString("cars", stringValue: "5")
// Other cases similar to above example
</code></pre>

<p>The last method <code>localizedString(_:intValue:fittingWidth:defaultValue:comment:)</code> allows you to get a localized string for int value. This method calls the above one and just turn the int value into string because all the framework operates on strings.</p>
<pre class="highlight plaintext"><code>I18n.localizedString("cars", intValue: 5)
</code></pre>
<a href='#contribution' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='contribution'>Contribution</h2>

<p>Swifternalization is open sourced so everyone may contribute if want to. If you want to develop it just fork the repo, do your work and create pull request. If you have some idea or question feel free to create issue and add proper tag for it.</p>

<p>There is no guide for contributors but if you added new functionality you must write unit tests for it.</p>
<a href='#swift_2' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='swift_2'>Swift 2</h2>

<p>Swifternalization supports Swift 2 and works on Xcode 7 beta 4. Please check out <em>swift2</em> branch.</p>
<a href='#things_to_do_in_future_releases' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='things_to_do_in_future_releases'>Things to do in future releases</h2>

<ul>
<li>Add more built-in expressions for another countries.</li>
<li>Add support for float numbers in built in expressions that uses regular expressions.</li>
</ul>
<a href='#license' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='license'>LICENSE</h2>

<p>Swifternalization is released under the MIT license.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2015 <a class="link" href="https://github.com/tomkowz/Swifternalization" target="_blank" rel="external">Tomasz Szulc</a>. All rights reserved. (Last updated: 2015-08-02)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.2.1</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
