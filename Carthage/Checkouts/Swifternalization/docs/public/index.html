<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Swifternalization Public API  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
  </head>
  <body>
    <a title="Swifternalization Public API  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Swifternalization Public API Docs</a> (100% documented)</p>
        <p class="header-right"><a href=""><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Swifternalization Public API Reference</a>
        <img id="carat" src="img/carat.png" />
        Swifternalization Public API  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
          <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/Swifternalization.html">Swifternalization</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
          <a href="Typealiases.html">Typealiases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:17Swifternalization4I18n">I18n</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p><img src="https://raw.githubusercontent.com/tomkowz/Swifternalization/master/page-assets/swifternalization-header.png" alt="Swifternalization: localize apps smarter"></p>

<p><a href="https://travis-ci.org/tomkowz/Swifternalization"><img src="https://travis-ci.org/tomkowz/Swifternalization.svg?branch=master" alt="Build Status"></a> 
<img src="https://img.shields.io/cocoapods/v/Swifternalization.svg" alt="CocoaPods Status">
<a href="https://flattr.com/submit/auto?user_id=tomkowz&url=http%3A%2F%2Fgithub.com%2Ftomkowz%2FSwifternalization" target="_blank"><img src="http://api.flattr.com/button/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0"></a></p>

<p>Swifternalization is library that helps in localizing apps. It is written in Swift.</p>
<a href='#features' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='features'>Features</h1>

<ul>
<li>[x] Pluralization support - Avoids using .stringdicts</li>
<li>[x] Expressions - inequality and regular expressions in Localizable.strings</li>
<li>[x] Shared expressions</li>
<li>[x] Built-in expressions</li>
<li>[x] Works similarly to NSLocalizedString() macro</li>
<li>[x] Uses Localizable.strings file as NSLocalizedString() macro does</li>
<li>[x] Comprehensive Unit Test Coverage</li>
<li>[x] Full documentation</li>
</ul>
<a href='#swifternalization' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='swifternalization'>Swifternalization</h1>

<p>Swifternalization helps in localizing apps in a smarter way. It has been created because of necessary to solve Polish language internalization problems but it is universal and works with every language. </p>
<a href='#failing_builds_temporary_section' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='failing_builds_temporary_section'>Failing builds (temporary section)</h2>

<p>I noticed that Travis CI sometimes reports that build failed. I don&rsquo;t know why, it can pass and fail on the same commit so this is very weird. Framework is of course working and it is covered by many unit tests. I think this is some issue with wrong Travis configuration. <a href="https://github.com/tomkowz/Swifternalization/issues/4">#4 Failing Travis CI builds</a></p>
<a href='#installation' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='installation'>Installation</h2>

<p>With CocoaPods:</p>
<pre class="highlight plaintext"><code>pod 'Swifternalization', '~&gt; 1.0.2'
</code></pre>

<p>Without CocoaPods:
If you want to integrate it with your project just import files from <em>Swifternalization/Swifternalization</em> directory.</p>
<a href='#documentation' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='documentation'>Documentation</h2>

<p>Swifternalization documentation covers 100% of the code, Yay! Two types of documentation have been generated. One covers only public API which is great for those who only wants to use the framework without looking inside. The second one covers all the API public, internal and private. (The best for now is to download repository since I&rsquo;m working on making it easily browsable).</p>

<ul>
<li><a href="https://github.com/tomkowz/Swifternalization/tree/master/docs/public">Public API documentation</a></li>
<li><a href="https://github.com/tomkowz/Swifternalization/tree/master/docs/framework">Full API documentation</a></li>
</ul>
<a href='#real_example' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='real_example'>Real Example</h2>

<p>Let&rsquo;s take a look on practical usage of Swifternalization. App supports both English and Polish languages. Naturally app contains two <em>Localizable.strings</em> files - one is Base for English (or English for English) and one is Polish&hellip; for Polish, obviously :)</p>

<p>App displays label with information that says when objects from the backend has been updated for the last time, e.g. <q>2 minutes ago</q>.</p>

<p>This shouldn&rsquo;t be problem in English:</p>

<ul>
<li>0, 2&hellip; second ago</li>
<li>1 second ago</li>
<li>&hellip;</li>
</ul>

<p>The same with minutes and hours. This is easy. Localization file for English will looks like this one:</p>
<pre class="highlight plaintext"><code>Localizable.strings (Base)
--------------------------

"one-second" = "1 second ago";
"many-seconds" = "%d seconds ago";

"one-minute" = "1 minute ago";    
"many-minutes" = "%d minutes ago";

"one-hour" = "1 hour ago";
"many-hours" = "%d hours ago";
</code></pre>

<p>Let&rsquo;s try with Polish language. As mentioned - this is tricky.</p>
<pre class="highlight plaintext"><code>Localizable.strings (Polish)
----------------------------

"one-second" = "1 sekundę temu";
"few-seconds" = "%d sekundy temu";
"many-seconds" = "%d sekund temu";

"one-minute" = "1 minutę temu";
"few-minutes" = "%d minuty temu";
"many-minutes" = "%d minut temu";

"one-hours" = "1 hodzinę temu";
"few-hours" = "%d godziny temu";
"many-hours" = "%d godzin temu";
</code></pre>

<p>Okay&hellip; there is 9 cases for now. But this is not the only thing to deal with. It depends on the number of seconds/minutes/hours to select proper one. Without some logic additional logic to find out which case should be used this is impossible to use proper one.</p>
<pre class="highlight plaintext"><code>- 0, (5 - 21) - "few-seconds"
- 1 - "one-second"
- (2 - 4), (22-24), (32-34), (42, 44), ..., (162-164), ... - "many-seconds"
</code></pre>

<p>The same logic for minutes and hours. </p>

<p>Here is nice table with <a href="http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html">Language Plural Rules</a> which covers cardinal forms of numbers in many languages - Many language handle plurality in their own way.</p>

<p>With Swifternalization this can be solved e.g. in this way:</p>
<pre class="highlight plaintext"><code>Localizable.strings (Base)
--------------------------
"time-seconds{one}" = "%d second ago";
"time-seconds{other}" = "%d seconds ago";

"time-minutes{one}" = "%d minute ago";
"time-minutes{other}" = "%d minutes ago";

"time-hours{one}" = "%d hour ago";
"time-hours{other}" = "%d hours ago";



Localizable.strings (Polish)
----------------------------
"time-seconds{one}" = "%d sekundę temu";
"time-seconds{few}" = "%d sekundy temu";
"time-seconds{many}" = "%d sekund temu";

"time-minutes{one}" = "%d minutę temu";
"time-minutes{few}" = "%d minuty temu";
"time-minutes{many}" = "%d minut temu";

"time-hours{one}" = "%d godzinę temu";
"time-hours{few}" = "%d godziny temu";
"time-hours{many}" = "%d godzin temu";
</code></pre>

<p>So the logic is in Swifternalization and you don&rsquo;t need write additional handling code for these cases.</p>

<p>And the call will look like this:</p>
<pre class="highlight plaintext"><code>Swifternalization.localizedExpressionString("time-seconds", value: 10)
</code></pre>

<p>or with <code>I18n</code> <em>typealias</em> (<em>I-18-letters-n, Internalization</em>):</p>
<pre class="highlight plaintext"><code>I18n.localizedExpressionString("time-seconds", value: 10)
</code></pre>

<p>There is easy way to add you own expression to handle your specific case with Swifternalization.</p>

<p>Swifternalization also drops need for having <em>.stringdicts</em> files like this one:</p>
<pre class="highlight plaintext"><code>&lt;plist version="1.0"&gt;
    &lt;dict&gt;
        &lt;key&gt;%d file(s) remaining&lt;/key&gt;
        &lt;dict&gt;
            &lt;key&gt;NSStringLocalizedFormatKey&lt;/key&gt;
            &lt;string&gt;%#@files@&lt;/string&gt;
            &lt;key&gt;files&lt;/key&gt;
            &lt;dict&gt;
                &lt;key&gt;NSStringFormatSpecTypeKey&lt;/key&gt;
                &lt;string&gt;NSStringPluralRuleType&lt;/string&gt;
                &lt;key&gt;NSStringFormatValueTypeKey&lt;/key&gt;
                &lt;string&gt;d&lt;/string&gt;
                &lt;key&gt;one&lt;/key&gt;
                &lt;string&gt;%d file remaining&lt;/string&gt;
                &lt;key&gt;other&lt;/key&gt;
                &lt;string&gt;%d files remaining&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/dict&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<a href='#getting_started' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='getting_started'>Getting Started</h2>

<p>Configuration is simple. The one thing that Swifternalization needs to works is <code>NSBundle</code> where <code>Localizable.strings</code> are placed.</p>

<p>Recommended is to configure it as fast as you can to be sure that before you want to get some localized key it will be able to return you something.</p>
<pre class="highlight plaintext"><code>    Swifternalization(bundle: NSBundle.mainBundle())
</code></pre>

<p>This call will create instance (you can get handle to it but you don&rsquo;t need it) and automatically set it as shared instance and you can easily work with it.</p>

<p>In <em>Localizable.strings</em> the syntax should looks like this:</p>
<pre class="highlight plaintext"><code>"key" = "value";
"key{expression}" = "value";
</code></pre>
<a href='#how_to_get_localized_string' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='how_to_get_localized_string'>How to get localized string</h3>

<p>Swifternalization allows developer to work with its class methods. There are few to use:</p>
<pre class="highlight plaintext"><code>localizedString(key: String, defaultValue: String? = nil) -&gt; String
</code></pre>

<p>Allows to get value for simple key. Works similar to <code>NSLocalizedString</code>. <code>key</code> is the key placed in <code>Localizable.strings</code> and <code>defaultValue</code> is the value that will be returned when there is no translation found for passed key. If <code>defaultValue</code> is nil then key will be return in such case.</p>

<p>The next one is for getting localized string with keys that contain some expressions:</p>
<pre class="highlight plaintext"><code>localizedExpressionString(key: String, value: String, defaultValue: String? = nil) -&gt; String
</code></pre>

<p>Similarly to the one above <code>key</code> is the key in <code>Localizable.strings</code>, <code>defaultValue</code> is also the same and methods behaves the same. There is additional parameter called <code>value</code>. The value is used for expression matchers to validate expressions and return proper localized value. We&rsquo;ll cover it soon.</p>

<p>As the method takes some <code>String</code> as a <code>value</code> and you probably will deal with <code>Int</code> there is alternative method to call:</p>
<pre class="highlight plaintext"><code>localizedExpressionString(key: String, value: Int, defaultValue: String? = nil) -&gt; String
</code></pre>
<a href='#expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='expressions'>Expressions</h2>

<p>As mentioned there are few <em>expression types</em>. Every expression type has their own <em>parser</em> and <em>matcher</em>.</p>

<p>There are 3 types:</p>

<ul>
<li><em>inequality</em> - this type of expression handles simple ineuqalities like: <em>%d&lt;3</em>, <em>%d&gt;10</em>, <em>%d=5</em>, <em>%d&lt;=3</em>, and so on.</li>
<li><em>inequality extended</em> - this is extended version of <em>inequality</em> with syntax like this: <em>2&lt;%d&lt;10</em>, <em>4&lt;=%d&lt;6</em>.</li>
<li><em>regex</em> - this types of expression uses regular expression. This is the most powerful ;)</li>
</ul>
<a href='#inequality' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='inequality'>Inequality</h3>

<p>It supports numbers for now (probably there will be only supports for numbers)). It is composed of several elements:</p>

<ul>
<li><em>ie:</em> - prefix of <em>inequality</em> expression</li>
<li><em>%d</em> - you have to always pass it, this means that <em>Int</em> will be used for this expression</li>
<li><em>&lt;, &lt;=, =, &gt;=, &gt;</em> - use one of inequality signs</li>
<li><em>1, 3, 5, 6, &hellip;</em> - value to match is the last one in this expression</li>
</ul>

<p>Example:</p>
<pre class="highlight plaintext"><code>"cars{ie:%d=1}" = "1 car";
"cars{ie:%d=0}" = "no cars";
"cars{ie:%d&gt;1}" = "%d cars";
</code></pre>
<a href='#inequality_extended' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='inequality_extended'>Inequality Extended</h3>

<p>This is a bit extended version of <em>inequality</em> expression. It is composed of 2 values, one value <q>marker</q> and two inequality signs.</p>

<ul>
<li><em>iex:</em> - prefix of <em>inequality extended</em> expression</li>
<li><em>%d</em> - it also works only with <em>Int*s for now so just pass *%d</em> in the place of the value to be matched</li>
<li>Inequality signs and possible values are the same like with <em>inequality</em> expression</li>
</ul>

<p>Expample:</p>
<pre class="highlight plaintext"><code>"tomatos{iex:2&lt;%d&lt;10}" = "%d tomatos is between 2 and 10";
</code></pre>
<a href='#regex' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='regex'>Regex</h3>

<p>This is the most powerful type of expression and probably will be most used by developers. It takes regular expression ;)</p>

<ul>
<li><em>exp:</em> - prefix of <em>regex</em> expression</li>
<li><em>string</em> - it takes string with regular expression</li>
</ul>

<p>Example: (police cars in Polish language)</p>
<pre class="highlight plaintext"><code>"police-cars{exp:^1$}" = "1 samochód policyjny";
"police-cars{exp:(((?!1).[2-4]{1})$)|(^[2-4]$)}" = "%d samochody policyjne";
"police-cars{exp:(.*(?=1).[0-9]$)|(^[05-9]$)|(.*(?!1).[0156789])}" = "%d samochodów policyjnych";
</code></pre>

<p>Powerful stuff, isn&rsquo;t it? :&gt;</p>

<p>PS. There is built in solution for Polish language so you can use it with doing just this:</p>
<pre class="highlight plaintext"><code>"police-cars{one}" = "1 samochód policyjny";
"police-cars{few}" = "%d samochody policyjne";
"police-cars{many}" = "%d samochodów policyjnych";
</code></pre>

<p>This feature is called <em><q>Shared Expression</q></em> and is covered below.</p>
<a href='#shared_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='shared_expressions'>Shared Expressions</h2>

<p>The functionality allows developer to observance of DRY principle and to avoid mistakes that exist because of reapeating the code in many places.</p>

<p>It is possible to create shared expression in your project and use it with no configuration with Swifternalization.</p>
<a href='#getting_started_of_shared_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='getting_started_of_shared_expressions'>Getting Started of Shared Expressions</h3>

<ol>
<li>Create <em>Expressions.strings</em> file in the same bundle when <em>Localizable.strings</em> file is.</li>
<li>Add shortcuts for your expressions and add your expressions ;)</li>
</ol>

<p>Example:</p>
<pre class="highlight plaintext"><code>Localizable.strings (Base)
-------------------
"cars{custom-1}" = "%d car";
"cars{custom-2}" = "%d cars";


Localizable.strings (Polish)
----------------------------
"cars{custom-1}" = "%d samochód";
"cars{custom-2}" = "%d samochody";
"cars{custom-3}" = "%d samochodów";


Expressions.strings (Base)
--------------------------
"custom-1" = "ie:%d=1";
"custom-2" = "exp:(^[^1])|(^\\d{2,})";


Expressions.strings (Polish)
---------------------------
"custom-1" = "ie:%d=1";
"custom-2" = "exp:(((?!1).[2-4]{1})$)|(^[2-4]$)";
"custom-3" = "exp:(.*(?=1).[0-9]$)|(^[05-9]$)|(.*(?!1).[0156789])";
</code></pre>

<p>Swifternalization load these <em>Expressions.strings</em> files and analyze them, and replace shortcuts for expressions with full expressions.</p>

<p>There is some duplication in Base and Polish version of expressions - <em>custom-1</em>. Instead of repeating this in entire language you want to cover you can keep it just in <em>Base</em> version of <em>Expressions.strings</em> file. Expressions that are find in <em>Base</em> and are not in preferred language file will be added to preferred language too to observance of DRY principle.</p>

<p>Swifternalization also handles the case of overriding built-in expressions. It gives you just few expressions for now like: <code>one</code>, <code>&gt;one</code>, <code>two</code>, <code>other</code> as base expressions and <code>few</code> and <code>many</code> for Polish. If any of your <em>Expressions.strings</em> version of file will override it Swifternalization will use your version.</p>
<a href='#demo' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='demo'>Demo</h2>

<p>There is demo project included in the repo. Just switch to proper target and run. It enumerated cars from 1 to 1000 and print them out to the console. Base (English) and Polish languages are supported. You can find there example of using simple primitive no-expression translation and also with experssions.</p>
<a href='#contribution_and_change_or_feature_requests' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='contribution_and_change_or_feature_requests'>Contribution and change or feature requests</h2>

<p>Swifternalization is open sources so everyone may contribute if want to. If you want to develop it just fork the repo, do you work and create pull request. If you have some idea or question feel free to create issue and add proper tag for it.</p>
<a href='#built_in_expressions' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='built_in_expressions'>Built-in expressions</h2>

<p>As mentioned in previous chapter Swifternalization has some built-in expressions and is ready to extend. If you want to add expressions specific for your country you can do it by creating class which conforms to <code>SharedExpressionProtocol</code>. Methods from protocol returns all expressions for your country. There is already <code>SharedBaseExpression</code> with some basic expressions and <code>SharedPolishExpression</code> with polish expressions for helping ordering numbers.</p>

<p>Example of the file ready for pull request should looks like this:</p>
<pre class="highlight plaintext"><code>class SharedPolishExpression: SharedExpressionProtocol {
    static func allExpressions() -&gt; [SharedExpression] {
        return [
            /**
            (2-4), (22-24), (32-4), ..., (..&gt;22, ..&gt;23, ..&gt;24)

            e.g.
            - 22 samochody, 1334 samochody, 53 samochody
            - 2 minuty, 4 minuty, 23 minuty
            */
            SharedExpression(k: "few", e: "exp:(((?!1).[2-4]{1})$)|(^[2-4]$)"),

            /**
            0, (5-9), (10-21), (25-31), ..., (..0, ..1, ..5-9)

            e.g.
            - 0 samochodów, 10 samochodów, 26 samochodów, 1147 samochodów
            - 5 minut, 18 minut, 117 minut, 1009 minut
            */
            SharedExpression(k: "many", e: "exp:(.*(?=1).[0-9]$)|(^[05-9]$)|(.*(?!1).[0156789])"),
        ]
    }
}
</code></pre>

<p>Also this is required to cover all shared expressions for a country with unit tests. You can find examples in the repo for e.g. Polish expressions.</p>
<a href='#swift_2' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='swift_2'>Swift 2</h2>

<p>Swifternalization supports Swift 2 and works on Xcode 7 beta 2. Please check <em>swift2</em> branch for that.</p>
<a href='#things_to_do_in_future_release' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='things_to_do_in_future_release'>Things to do in future release:</h2>

<ul>
<li>Add more built-in expressions for another countries.</li>
</ul>
<a href='#license' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='license'>LICENSE</h2>

<p>Swifternalization is released under the MIT license.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2015 <a class="link" href="https://github.com/tomkowz/Swifternalization" target="_blank" rel="external">Tomasz Szulc</a>. All rights reserved. (Last updated: 2015-06-30)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.2.1</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
